## Requirements

- GitLab;

- Kubernetes to run the GitLab Runner.

## Installing and registering the GitLab Runner

Follow [official instructions](https://docs.gitlab.com/runner/register/index.html) to install the GitLab Runner in Kubernetes and register it.

## Configuring the GitLab Runner

Modify the configuration of the registered GitLab Runner by adding the following parameters to its `config.toml`:

```toml
[[runners]]
  name = <name of the registered Runner>
  [runners.kubernetes]
    namespace = "gitlab-ci"
    [runners.kubernetes.pod_annotations]
      "container.apparmor.security.beta.kubernetes.io/build" = "unconfined"
    [runners.kubernetes.pod_security_context]
      run_as_non_root = true
      run_as_user = 1000
      run_as_group = 1000
      fs_group = 1000
```

Add the following parameters to enable `.werf` and `/builds` caching (recommended):

```toml
[[runners]]
  name = <name of the registered Runner>
  [runners.kubernetes]
    [[runners.kubernetes.volumes.pvc]]
      name = "gitlab-ci-kubernetes-executor-werf-cache"
      mount_path = "/home/build/.werf"
    [[runners.kubernetes.volumes.pvc]]
      name = "gitlab-ci-kubernetes-executor-builds-cache"
      mount_path = "/builds"
```

... or these if caching is not needed:

```toml
[[runners]]
  name = <name of the registered Runner>
  [runners.kubernetes]
    [[runners.kubernetes.volumes.empty_dir]]
      name = "gitlab-ci-kubernetes-executor-werf-cache"
      mount_path = "/home/build/.werf"
    [[runners.kubernetes.volumes.empty_dir]]
      name = "gitlab-ci-kubernetes-executor-builds-cache"
      mount_path = "/builds"
```

Add one more parameter if you are going to deploy applications using werf to the same cluster in which the GitLab Runner is running:

```toml
[[runners]]
  name = <name of the registered Runner>
  [runners.kubernetes]
    service_account = "gitlab-ci-kubernetes-executor"
```

You may want to perform [advanced configuration](https://docs.gitlab.com/runner/configuration/advanced-configuration.html) of the GitLab Runner as well.

## Configuring Kubernetes

If you enabled caching of `.werf` and `/builds` in the GitLab Runner configuration, create appropriate PersistentVolumeClaims in the cluster, for example:

```shell
$ kubectl create -f - <<EOF
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: gitlab-ci-kubernetes-executor-werf-cache
  namespace: gitlab-ci
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 10Gi
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: gitlab-ci-kubernetes-executor-builds-cache
  namespace: gitlab-ci
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 30Gi
EOF
```

If you are going to deploy applications to the same cluster in which GitLab Runner is running, configure RBAC in the cluster to run GitLab Runner with the following command:

```shell
$ kubectl create -f - <<EOF
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: gitlab-ci-kubernetes-executor
  namespace: gitlab-ci
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: gitlab-ci-kubernetes-executor
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
  - kind: ServiceAccount
    name: gitlab-ci-kubernetes-executor
    namespace: gitlab-ci
EOF
```

> For greater security, consider creating a more restricted ClusterRole/Role and using it instead of the `cluster-admin` cluster role above.

If the Kubernetes nodes on which the GitLab Runner is hosted run Linux kernel version 5.12 or lower, enable FUSE for GitLab Runner on that cluster using the following command:

```shell
$ kubectl create -f - <<EOF
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fuse-device-plugin
  namespace: kube-system
spec:
  selector:
    matchLabels:
      name: fuse-device-plugin
  template:
    metadata:
      labels:
        name: fuse-device-plugin
    spec:
      hostNetwork: true
      containers:
      - image: soolaugust/fuse-device-plugin:v1.0
        name: fuse-device-plugin-ctr
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop: ["ALL"]
        volumeMounts:
          - name: device-plugin
            mountPath: /var/lib/kubelet/device-plugins
      volumes:
        - name: device-plugin
          hostPath:
            path: /var/lib/kubelet/device-plugins
---
apiVersion: v1
kind: LimitRange
metadata:
  name: enable-fuse
  namespace: gitlab-ci
spec:
  limits:
  - type: "Container"
    default:
      github.com/fuse: 1
EOF
```

## Configuring the GitLab project

- Enable [Require a successful pipeline for merge requests](https://docs.gitlab.com/ee/user/project/merge_requests/merge_when_pipeline_succeeds.html#require-a-successful-pipeline-for-merge).

- Enable the option to [auto-cancel redundant pipelines](https://docs.gitlab.com/ee/ci/pipelines/settings.html#auto-cancel-redundant-pipelines).

- [Create ans save the access token](https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html#create-a-project-access-token) to clean up the no longer needed images in the container registry with the following parameters:

  - **Token name:** `werf-images-cleanup`;

  - **Role:** `developer`;

  - **Scopes:** `api`.

- Add the following variables to the [project variables](https://docs.gitlab.com/ee/ci/variables/#for-a-project):

  - werf version:

    - **Key:** `WERF_VERSION`;

    - **Value:** `{{ include.version }} {{ include.channel }}`.

  - Access token to clean up the no longer needed images:

    - **Key:** `WERF_IMAGES_CLEANUP_PASSWORD`;

    - **Value:** `<"werf-images-cleanup" access token you saved earlier>`;

    - **Protect variable:** `yes`;

    - **Mask variable:** `yes`.

- [Add a scheduled nightly task](https://docs.gitlab.com/ee/ci/pipelines/schedules.html#add-a-pipeline-schedule) to clean up the no longer needed images in the container registry and set the `main`/`master` branch as the **Target branch**.

## Configuring the container registry

[Enable garbage collection](https://docs.gitlab.com/ee/administration/packages/container_registry.html#container-registry-garbage-collection) for your container registry.

## Configuring CI/CD of the project

Example of using werf with GitLab CI:

```yaml
# .gitlab-ci.yml:
stages:
- prod
- cleanup

default:
  image:
    name: "registry.werf.io/werf/werf:{{ include.version }}-{{ include.channel }}-{{ include.werfImageDistro }}"
    pull_policy: always
  before_script:
  - source "$(werf ci-env gitlab --as-file)"
  tags: ["<tag of the registered GitLab Runner>"]

prod:
  stage: prod
  script:
  - werf converge
  environment:
    name: prod
  rules:
  - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE != "schedule"
    when: manual

images:cleanup:
  stage: cleanup
  script:
    - werf cr login -u nobody -p "${WERF_IMAGES_CLEANUP_PASSWORD:?}" "${WERF_REPO:?}"
    - werf cleanup
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE == "schedule"
```

{% comment %}
TODO:
* change kube context in jobs in CI
* ```
  image:
      name: "registry.werf.io/werf/werf:1.2-stable"
      pull_policy: always
  before_script:
  - source "$(werf ci-env gitlab --as-file)"
  ```
{% endcomment %}
